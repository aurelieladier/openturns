%feature("docstring") OT::KarhunenLoeveQuadratureFactory
"Computation of Karhunen-Loeve decomposition using Quadrature approximation.

Parameters
----------
domain : :class:`~openturns.Domain`
    The domain on which the Fredholm equation is defined.
experiment : :class:`~openturns.WeightedExperiment`
    The algorithm used to discretize the integrale defining the Fredholm equation.
basis : :class:`~openturns.Basis`
    The basis from which the base functions are taken to define the finite space on which live the approximate eigenfunctions.
basisSize : int
    The dimension of the finite approximation space.
mustScale : bool
    Flag to tell if a scaling function has to be inserted in the base functions.
threshold : float
    The minimal relative amplitude of the eigenvalues to consider in the decomposition wrt the maximum eigenvalue.

Notes
-----
The Karhunen-Loeve decomposition using Quadrature approximation allows to approximate the solution of the second kind Fredholm equation:

.. math::

    \int_{\cD} \mat{C}(\vect{s},\vect{t})\vect{\phi}_n(\vect{s})\di{\vect{s}}=\lambda_n\vect{\phi}_n(\vect{t})


with :math:`\mat{C}: \cD\times\cD \mapsto \cS^+_d(\Rset)` a given covariance function, :math:`\lambda_n` a nonincreasing sequence of nonnegative values (the **eigenvalues** of the equation) and :math:`\vect{\phi}_n: \cD\mapsto\Rset^d` the associated sequence of **eigenfunctions**, normalized by :math:`\int_{\cD_N}\|\vect{\phi}_n(\vect{s})\|^2\di{\vect{s}}=1`.

The Karhunen-Loeve quadrature approximation consists in replacing the integrals defining the Fredholm equation by its quadrature approximation counterpart:

.. math::
   \int_{\Rset^d} \mat{C}(\vect{s},\vect{t})\vect{\phi}_n(\vect{s})\di{\vect{s}}\simeq\sum_{\ell=1}^L\omega_{\ell}\mat{C}(\vect{\xi}_{\ell},\vect{t})\vect{\phi}_n(\vect{\xi}_{\ell})\dfrac{\fcar{\vect{\xi}_{\ell}}{\cD}}{p(\vect{\xi}_{\ell})}

Where :math:`(\omega_{\ell},\vect{\xi}_{\ell})_{\ell=1,\dots,L}` is a quadrature formula wrt the density function :math:`p` such that its support contains :math:`\cD`, ie the discrete measure :math:`\sum_{\ell=1}^L\omega_{\ell}\delta_{\vect{\xi}_{\ell}}` is an approximation of the probability measure defined by :math:`p`.

The eigenfunctions :math:`\phi_n` are decomposed into a functional basis :math:`(\theta_p)_{p=1,\dots,P}`:

.. math::
    \forall \vect{s}\in\cD,\quad \phi_n(\vect{s})=\sum_{p=1}^P\vect{\alpha}_n^p\theta_p(\vect{s})

and the associated coefficients are found using a Galerkin projection on the space generated by :math:`(\theta_p)_{p=1,\dots,P}`.
   

Examples
--------
Create a Karhunen-Loeve Quadrature factory:

>>> import openturns as ot
>>> domain = ot.Interval([-1.0]*2, [1.0]*2)
>>> basis = ot.OrthogonalProductPolynomialFactory([ot.LegendreFactory()]*2)
>>> basisSize = 10
>>> samplingSize = 100
>>> experiment = ot.LHSExperiment(basis.getMeasure(), samplingSize)
>>> mustScale = False
>>> threshold = 0.01
>>> factory = ot.KarhunenLoeveQuadratureFactory(domain, experiment, basis, basisSize, mustScale, threshold)"

// ---------------------------------------------------------------------
%feature("docstring") OT::KarhunenLoeveQuadratureFactory::build
"Computation of the eigenvalues and eigen functions.

Parameters
----------
C : :class:`~openturns.CovarianceModel`, :math:`\mat{C}: \cD\times\cD \mapsto \cS^+_d(\Rset)`
    The covariance model.
ev : :class:`~openturns.NumericalPoint`
    The eigenvalues :math:`\lambda_n` in descending order such that :math:`\lambda_n/\lambda_0\geq\mathrm{threshold}`

Returns
-------
functions : :class:`~openturns.Basis`
    Eigen functions of the covariance model as a basis of functions using :class:`~openturns.QuadratureLagrangeEvaluationImplementation`.

Examples
--------
>>> import openturns as ot
>>> domain = ot.Interval([-1.0]*2, [1.0]*2)
>>> basis = ot.OrthogonalProductPolynomialFactory([ot.LegendreFactory()]*2)
>>> basisSize = 10
>>> samplingSize = 100
>>> experiment = ot.LHSExperiment(basis.getMeasure(), samplingSize)
>>> mustScale = False
>>> threshold = 0.01
>>> factory = ot.KarhunenLoeveQuadratureFactory(domain, experiment, basis, basisSize, mustScale, threshold)
>>> model = ot.AbsoluteExponential([1.0]*2)
>>> ev = ot.NumericalPoint()
>>> functions = factory.build(model, ev)"
